/* TagVFS configuration snapshot utility executable.
 * AGPL-3.0 license
 * Initial rev Misha Turnbull 2023-11-12
 *
 * Impelements the configuration snapshot utility.
 */

#include "cfgsnapshot_exe.h"

/* (not a doc comment!)
 *
 * These variables are compiled in from _config_h.o and _version_autogen.o
 * files that don't exist.  They will not exist until compile time.  You won't
 * find them anywhere in the sourcecode.
 *
 * If you're here because something broke, please also pay careful attention to
 * the CMakeLists.txt responsible for building this executable.  The overall
 * process is something like this:
 *
 * 1. User presses "please build" button
 * 2. CMake makes its way over to this executable
 * 3. Two custom targets have been declared as dependencies for this binary:
 *    ``config_h`` and ``_version_autogen`` (no ``.o`` on these ones!)
 * 4. CMake uses the linker to build these objects
 * 5. The ``.o`` files generated by the linker are compiled alongside *this*
 *    file as sourcecode
 * 6. Those ``.o`` files declare the six symbols below
 *
 * .. seealso::
 *
 *    The laundry list of StackOverflow questions that led this into existence:
 *
 *    * https://stackoverflow.com/q/4158900
 *    * https://stackoverflow.com/q/52830564
 *    * https://stackoverflow.com/q/14776463
 *    * https://stackoverflow.com/q/38609303
 *    * https://stackoverflow.com/q/11813271
 *    * https://stackoverflow.com/q/65407610
 *    * https://stackoverflow.com/q/19169039
 *
 *    The :file:`CMakeLists.txt` responsible for this executable
 *
 */
extern char _binary_config_h_start[];
extern char _binary_config_h_end[];
extern size_t _binary_config_h_size;
extern char _binary_version_autogen_h_start[];
extern char _binary_version_autogen_h_end[];
extern size_t _binary_version_autogen_h_size;

static char doc[] = "Dump information about TagVFS configuration.";
static char args_doc[] = "";

static struct argp_option options[] = {
    {"headers", 'h', 0, 0, "Print compile-time configuration headers", 0},

    {0, 0, 0, 0, 0, 0}
};

struct arguments {
    char do_headers;
};

static int parse_opt(int key, char *arg, struct argp_state *state) {
    struct arguments *arguments = state->input;

    if (arg != NULL) {
        return ARGP_ERR_UNKNOWN;
    }

    switch (key) {
        case 'h':
            arguments->do_headers = 1;
            break;

        case ARGP_KEY_ARG:
        default:
            return ARGP_ERR_UNKNOWN;
    }

    return 0;
}

static struct argp argp = { options, parse_opt, args_doc, doc, 0, 0, 0 };

int main(int argc, char **argv) {
    // set defaults, then parse arguments
    struct arguments arguments;
    arguments.do_headers = 0;
    argp_parse(&argp, argc, argv, 0, 0, &arguments);

    // make sure we actually *do* something
    if (arguments.do_headers < 1) {
        fprintf(stderr,
                "ERROR: no actions specified!  See '--help' option\n");
        return 1;
    }

    if (arguments.do_headers) {
        for (char *p = _binary_config_h_start;
                p != _binary_config_h_end;
                p++) {
            putchar(*p);
        }
        for (char *p = _binary_version_autogen_h_start;
                p != _binary_version_autogen_h_end;
                p++) {
            putchar(*p);
        }
    }

    return 0;
}

